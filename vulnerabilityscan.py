import socket
import argparse
import threading
import re
import json
import nmap
from datetime import datetime
import ssl
import requests
from bs4 import BeautifulSoup
from cryptography import x509
from cryptography.hazmat.backends import default_backend
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Thread lock for thread-safe operations
lock = threading.Lock()

def resolve_target(target):
    """
    Resolve the target URL or IP address.

    Args:
    - target (str): Target URL or IP address.

    Returns:
    - tuple: Resolved IP address and port.
    """
    if "http" in target:
        try:
            parsed_url = requests.utils.urlparse(target)
            hostname = parsed_url.hostname
            port = parsed_url.port if parsed_url.port else (443 if parsed_url.scheme == "https" else 80)
            ip_address = socket.gethostbyname(hostname)
            return ip_address, port
        except Exception as e:
            logging.error(f"Error resolving URL {target}: {e}")
            return None, None
    else:
        return target, None

def get_banner(sock, target, port):
    """
    Get the service banner from a socket.

    Args:
    - sock (socket): The connected socket.
    - target (str): The target IP address.
    - port (int): Target port number.

    Returns:
    - str: The service banner.
    """
    try:
        if port == 443:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            with context.wrap_socket(sock, server_hostname=target) as ssock:
                ssock.send(b"HEAD / HTTP/1.1\r\nHost: %b\r\n\r\n" % target.encode())
                return ssock.recv(1024).decode().strip()
        else:
            return sock.recv(1024).decode().strip()
    except Exception as e:
        logging.error(f"Error getting banner: {e}")
        return ""

def vulnerability_scanner(target, port, vuln_list, results, retries=3):
    """
    Scan a target IP address and port for specified vulnerabilities.

    Args:
    - target (str): Target IP address.
    - port (int): Target port number.
    - vuln_list (list): List of vulnerabilities to check for.
    - results (list): List to store results.
    - retries (int): Number of retries for the connection.

    Returns:
    - None
    """
    for attempt in range(retries):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((target, port))

            if port == 80:
                check_http_vulnerabilities(sock, target, port, vuln_list, results)
            elif port == 443:
                check_https_vulnerabilities(sock, target, port, vuln_list, results)
            else:
                # Add more checks for other services or protocols if needed
                pass

            sock.close()
            return
        except socket.timeout:
            logging.warning(f"Connection timeout while scanning port {port}, attempt {attempt+1}/{retries}")
        except socket.error as e:
            logging.error(f"Error scanning for vulnerabilities on port {port}: {e}, attempt {attempt+1}/{retries}")
        finally:
            sock.close()
    logging.error(f"Failed to scan port {port} after {retries} attempts")

def check_http_vulnerabilities(sock, target, port, vuln_list, results):
    """
    Check for HTTP vulnerabilities by analyzing HTTP responses.

    Args:
    - sock (socket): The connected socket.
    - target (str): Target IP address.
    - port (int): Target port number.
    - vuln_list (list): List of vulnerabilities to check for.
    - results (list): List to store results.

    Returns:
    - None
    """
    try:
        sock.send(b"GET / HTTP/1.1\r\nHost: %b\r\n\r\n" % target.encode())
        response = sock.recv(1024).decode().strip()
        logging.info(f"HTTP response from {target}:{port} - {response}")

        if "Server" in response:
            server_info = extract_server_info(response)
            vulnerabilities = check_cve_vulnerabilities(server_info)
            vulnerabilities_found = [vuln for vuln in vuln_list if vuln in response] + vulnerabilities
            with lock:
                results.append({
                    "target": target,
                    "port": port,
                    "protocol": "tcp",
                    "state": "open",
                    "service": "http",
                    "vulnerabilities": vulnerabilities_found
                })
                logging.info(f"Vulnerabilities found on port {port}: {vulnerabilities_found}")
        else:
            logging.info(f"No vulnerabilities found on port {port}")

    except Exception as e:
        logging.error(f"Error checking HTTP vulnerabilities on port {port}: {e}")

def check_https_vulnerabilities(sock, target, port, vuln_list, results):
    """
    Check for HTTPS vulnerabilities by analyzing HTTPS responses.

    Args:
    - sock (socket): The connected socket.
    - target (str): Target IP address.
    - port (int): Target port number.
    - vuln_list (list): List of vulnerabilities to check for.
    - results (list): List to store results.

    Returns:
    - None
    """
    try:
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        with context.wrap_socket(sock, server_hostname=target) as ssock:
            ssock.send(b"HEAD / HTTP/1.1\r\nHost: %b\r\n\r\n" % target.encode())
            response = ssock.recv(1024).decode().strip()
            logging.info(f"HTTPS response from {target}:{port} - {response}")

            # Check for SSL/TLS certificate issues
            cert = ssock.getpeercert(binary_form=True)
            check_ssl_certificate(cert, target, port, results)

            if "SSL" in response:
                server_info = extract_server_info(response)
                vulnerabilities = check_cve_vulnerabilities(server_info)
                vulnerabilities_found = [vuln for vuln in vuln_list if vuln in response] + vulnerabilities
                with lock:
                    results.append({
                        "target": target,
                        "port": port,
                        "protocol": "tcp",
                        "state": "open",
                        "service": "https",
                        "vulnerabilities": vulnerabilities_found
                    })
                    logging.info(f"Vulnerabilities found on port {port}: {vulnerabilities_found}")
            else:
                logging.info(f"No vulnerabilities found on port {port}")

    except Exception as e:
        logging.error(f"Error checking HTTPS vulnerabilities on port {port}: {e}")

def check_ssl_certificate(cert, target, port, results):
    """
    Check SSL/TLS certificate for issues.

    Args:
    - cert (bytes): SSL certificate details in binary form.
    - target (str): Target IP address.
    - port (int): Target port number.
    - results (list): List to store results.

    Returns:
    - None
    """
    try:
        cert_details = x509.load_der_x509_certificate(cert, default_backend())
        issuer = cert_details.issuer.rfc4514_string()
        subject = cert_details.subject.rfc4514_string()
        expiry_date = cert_details.not_valid_after

        logging.info(f"SSL Certificate Details for {target}:{port}")
        logging.info(f"Issuer: {issuer}")
        logging.info(f"Subject: {subject}")
        logging.info(f"Expiry Date: {expiry_date}")

        if expiry_date < datetime.now():
            with lock:
                results.append({
                    "target": target,
                    "port": port,
                    "protocol": "tcp",
                    "state": "open",
                    "service": "https",
                    "vulnerabilities": ["Expired SSL Certificate"]
                })
                logging.warning(f"Expired SSL certificate for {target}:{port}")

    except Exception as e:
        logging.error(f"Error checking SSL certificate for {target}:{port}: {e}")

def extract_server_info(response):
    """
    Extract server information from the HTTP/HTTPS response.

    Args:
    - response (str): HTTP/HTTPS response.

    Returns:
    - dict: Extracted server information.
    """
    server_info = {}
    match = re.search(r"Server: ([^\r\n]+)", response)
    if match:
        server_info["server"] = match.group(1)
    return server_info

def check_cve_vulnerabilities(server_info):
    """
    Check for CVE vulnerabilities based on server information.

    Args:
    - server_info (dict): Extracted server information.

    Returns:
    - list: List of CVE vulnerabilities found.
    """
    vulnerabilities = []
    if "server" in server_info:
        server_version = server_info["server"]
        url = f"https://cve.circl.lu/api/search/{server_version}"
        try:
            response = requests.get(url)
            if response.status_code == 200:
                cve_data = response.json()
                for item in cve_data:
                    vulnerabilities.append(f"{item['id']} - {item['summary']}")
            else:
                logging.error(f"Error fetching CVE data: {response.status_code}")
        except Exception as e:
            logging.error(f"Error fetching CVE data: {e}")
    return vulnerabilities

def display_splash_screen():
    """
    Display the splash screen with the application name and usage instructions.
    """
    print(r"""
    ########  ##     ## ########  ########  ##       ######## ########     ###    #### ##    ## 
    ##     ## ##     ## ##     ## ##     ## ##       ##       ##     ##   ## ##    ##  ###   ## 
    ##     ## ##     ## ##     ## ##     ## ##       ##       ##     ##  ##   ##   ##  ####  ## 
    ########  ##     ## ########  ########  ##       ######   ########  ##     ##  ##  ## ## ## 
    ##        ##     ## ##   ##   ##        ##       ##       ##   ##   #########  ##  ##  #### 
    ##        ##     ## ##    ##  ##        ##       ##       ##    ##  ##     ##  ##  ##   ### 
    ##         #######  ##     ## ##        ######## ######## ##     ## ##     ## #### ##    ## 

Usage:
    python vulnerability_scanner.py <target_ip_or_url> <ports> [-v <vuln1> <vuln2> ...]

Example:
    python vulnerability_scanner.py 192.168.1.100 80 443 -v "Apache/2.4.29" "OpenSSH_7.6p1"
    """)

def parse_arguments():
    """
    Parse command-line arguments.
    """
    parser = argparse.ArgumentParser(description="Vulnerability Scanner Tool")
    parser.add_argument("target", help="Target IP address or URL")
    parser.add_argument("ports", type=int, nargs='+', help="Target ports to scan")
    parser.add_argument("-v", "--vuln", nargs='+', help="List of vulnerabilities to check for")
    parser.add_argument("-o", "--output", help="Output file to save the results")
    return parser.parse_args()

def nmap_scan(target, ports, results):
    """
    Perform an Nmap scan for deeper analysis.

    Args:
    - target (str): Target IP address.
    - ports (list): List of ports to scan.
    - results (list): List to store results.

    Returns:
    - None
    """
    nm = nmap.PortScanner()
    nm.scan(target, arguments='-p ' + ','.join(map(str, ports)))
    for proto in nm[target].all_protocols():
        lport = nm[target][proto].keys()
        for port in lport:
            state = nm[target][proto][port]['state']
            service = nm[target][proto][port]['name']
            with lock:
                results.append({
                    "target": target,
                    "port": port,
                    "protocol": proto,
                    "state": state,
                    "service": service,
                    "vulnerabilities": []  # Initialize vulnerabilities list
                })
                logging.info(f"Scanned {target}:{port} ({proto}): {state}, {service}")

def scan_target(target, ports, vuln_list, results, output_file):
    """
    Scan a target for vulnerabilities.

    Args:
    - target (str): Target IP address or URL.
    - ports (list): List of ports to scan.
    - vuln_list (list): List of vulnerabilities to check for.
    - results (list): List to store results.
    - output_file (str): Output file to save the results.

    Returns:
    - None
    """
    ip_address, url_port = resolve_target(target)
    if not ip_address:
        logging.error(f"Could not resolve target {target}")
        return

    if url_port:
        ports = [url_port]

    threads = []
    for port in ports:
        t = threading.Thread(target=vulnerability_scanner, args=(ip_address, port, vuln_list, results))
        t.start()
        threads.append(t)
    for t in threads:
        t.join()

    nmap_scan(ip_address, ports, results)  # Perform an Nmap scan for deeper analysis

    generate_report(results, output_file)
    display_results(results)

def generate_report(results, output_file):
    """
    Generate a report of the scan results.

    Args:
    - results (list): List of scan results.
    - output_file (str): Output file to save the report.

    Returns:
    - None
    """
    report = {
        "scan_time": str(datetime.now()),
        "results": results
    }
    with open(output_file, 'w') as f:
        json.dump(report, f, indent=4)
    logging.info(f"Scan report saved to {output_file}")

def display_results(results):
    """
    Display the scan results on the screen.

    Args:
    - results (list): List of scan results.

    Returns:
    - None
    """
    print("\nScan Results:")
    for result in results:
        target = result.get("target", "N/A")
        port = result.get("port", "N/A")
        protocol = result.get("protocol", "N/A")
        state = result.get("state", "N/A")
        service = result.get("service", "N/A")
        vulnerabilities = ", ".join(result.get("vulnerabilities", [])) if result.get("vulnerabilities") else "N/A"
        print(f"Target: {target}, Port: {port}, Protocol: {protocol}, State: {state}, Service: {service}, Vulnerabilities: {vulnerabilities}")

if __name__ == "__main__":
    display_splash_screen()
    args = parse_arguments()

    target = args.target
    ports = args.ports
    vuln_list = args.vuln if args.vuln else [
    "Apache/2.2.3", "OpenSSH_4.7", "nginx/1.14.0", "nginx/1.16.0", "nginx/1.18.0",
    "nginx/1.19.0", "nginx/1.20.0", "nginx/1.21.0", "nginx/1.22.0", "nginx/1.23.0",
    "nginx/1.24.0", "nginx/1.25.0", "Apache/2.4.18", "Apache/2.4.29", "Apache/2.4.39",
    "OpenSSH_7.4", "OpenSSH_7.6", "OpenSSH_7.9", "OpenSSH_8.1", "OpenSSH_8.2",
    "OpenSSH_8.3", "OpenSSH_8.4", "OpenSSH_8.5", "OpenSSH_8.6", "OpenSSH_8.7",
    "OpenSSH_8.8", "Microsoft-IIS/7.5", "Microsoft-IIS/8.0", "Microsoft-IIS/8.5",
    "Microsoft-IIS/10.0", "nginx/1.19.10", "nginx/1.18.0", "nginx/1.21.1",
    "nginx/1.20.2", "nginx/1.22.1", "nginx/1.23.2", "nginx/1.24.3", "nginx/1.25.4",
    "Apache Tomcat/8.0.36", "Apache Tomcat/9.0.37", "Apache Tomcat/10.0.3",
    "nginx/1.19.9", "Apache/2.4.41", "Apache/2.4.43", "Apache/2.4.46",
    "nginx/1.21.4", "nginx/1.22.1", "nginx/1.23.3", "OpenSSH_8.7p1", "nginx/1.21.6",
    "Apache/2.4.20", "Apache/2.4.35", "Apache/2.4.38", "OpenSSH_7.7", "OpenSSH_8.0",
    "OpenSSH_8.9", "OpenSSH_9.0", "Microsoft-IIS/8.5.1", "Microsoft-IIS/9.0", "Microsoft-IIS/10.1",
    "nginx/1.26.0", "nginx/1.27.0", "nginx/1.28.0", "nginx/1.29.0", "nginx/1.30.0",
    "nginx/1.31.0", "nginx/1.32.0", "nginx/1.33.0", "nginx/1.34.0", "nginx/1.35.0",
    "Apache Tomcat/8.5.65", "Apache Tomcat/9.0.50", "Apache Tomcat/10.1.8",
    "nginx/1.22.2", "nginx/1.23.4", "nginx/1.24.5", "nginx/1.25.6", "nginx/1.26.7",
    "Apache/2.4.50", "Apache/2.4.55", "Apache/2.4.60", "OpenSSH_8.7p2", "OpenSSH_8.7p3",
    "OpenSSH_8.7p4", "OpenSSH_8.7p5", "OpenSSH_8.7p6", "OpenSSH_8.7p7", "OpenSSH_8.7p8",
    "Microsoft-IIS/10.2", "Microsoft-IIS/10.3", "Microsoft-IIS/10.4", "Microsoft-IIS/10.5",
    "Microsoft-IIS/10.6", "nginx/1.36.0", "nginx/1.37.0", "nginx/1.38.0", "nginx/1.39.0",
    "nginx/1.40.0", "nginx/1.41.0", "nginx/1.42.0", "nginx/1.43.0", "nginx/1.44.0",
    "Apache Tomcat/8.5.70", "Apache Tomcat/9.0.55", "Apache Tomcat/10.1.15",
    "nginx/1.45.0", "nginx/1.46.0", "nginx/1.47.0", "nginx/1.48.0", "nginx/1.49.0",
    "nginx/1.50.0", "nginx/1.51.0", "nginx/1.52.0", "nginx/1.53.0", "nginx/1.54.0"]
    output_file = args.output if args.output else "scan_report.json"

    results = []
    scan_target(target, ports, vuln_list, results, output_file)
